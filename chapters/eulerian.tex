\chapter{Eulerian Domain: Finite Element Method}

	\lsymb[f]{$\mathcal{T}_h$}{Finite Element mesh}{-}{th}		
	\lsymb[f]{$T$}{Cell of Finite Element mesh}{-}{t}			
	
	\lsymb[f]{$v$}{Test function}{-}{v}				
	\lsymb[f]{$V$}{Trial vector function space}{-}{vte}				
	\lsymb[f]{$\hat{V}$}{Test vector function space}{-}{vtr}					
	\gsymb[f]{$\Omega$}{Fluid domain}{-}{x}	
	\gsymb[f]{$\Omega_E$}{Eulerian fluid domain}{-}{xe}	
	\gsymb[f]{$\Omega_L$}{Lagrangian fluid domain}{-}{xl}	
	\gsymb[f]{$\partial \Omega$}{Boundary of the domain $\Omega$}{-}{xdd}	

%------------------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------------------
%\section{Purpose of eulerian domain}
Standard \printAcron{Computation Fluid Dynamics}{CFD} method discretizes the fluid into smaller regions, known as grids, and solves the set of Navier-Stokes equations in this region. This type of formulation is referred to as Eulerian method as we are evaluating the change of flow property in a given volume.

For the hybrid method, we use the Navier-Stokes grid formulation in the near-body region. The advantage of using the Eulerian method at this region is that it is much more efficient in resolving the boundary layer than the typical Vortex Particle Method. We can directly enforce the wall boundary condition at the wall boundary of the Eulerian domain, solving the problem of vorticity generation from a body. In the hybrid coupling strategy, we will interpolate this newly resolved near-wall solution on to the Lagrangian domain, where the vortex blobs will efficiently evolve the particles from the Lagrangian frame point.

The various approaches to solve the fluid dynamics problem from a Eulerian reference frame. \indexAcron{Finite Volume Method }{FVM}, \indexAcron{Finite Difference Method}{FDM}, and \indexAcron{Finite Element Method}{FEM} are the common choice for solving the Navier-Stokes problem and differ by the way they approach to solve the problem. FVM divides the domain into volumes where it enforces the conservation of mass and momentum in each sub-domains. FDM divides the domain into nodes and use local Taylor expansions to approximate the partial differential equations. FEM divides the domain into elements and solves the problem using variational calculus. So, in the end, the choice of Eulerian method does not have a direct impact on the coupling with the Lagrangian method. 

We have decided to use the FEM packages provided by the \texttt{FEniCS} project as they have be already implemented efficient, multi-threaded algorithms for solving differential equation and provide extensive features for future developments such as adaptive mesh refinement, fluid-structure interaction, and efficient computation of turbulence.

\section{Introduction to Finite Element Method}

\printAcron{Finite Element Method}{FEM} is numerical method to solve for the solution of a given differential equation. It is solved by describing it as a variation problem, and by minimizing the error we can reach a approximate solution for the boundary value problem \cite{Brenner2008}. So, the FEM approximates the unknown variables and converts the partial differential equations to algebraic equations. It was traditionally used for solid mechanics, for the analysis of aircraft structures \cite{Rao2005}, but have since then used to solve the Navier-Stokes fluid dynamics problems \cite{Guermond2006} \cite{Johnston2004} \cite{Guermond2003}.

\subsection*{Finite element discretization}

Finite Element solves by dividing the domain of interest into small, simple regions known as ``finite elements". These ``elements" are connected at the joints and are called nodes or nodal points. We use these sets of node and elements to represent the actual variation in the field (such as displacement, velocity, pressure or temperature) using simple functions, known as basis functions. Therefore, we have transformed a domain of infinite \indexAcron{Degrees of Freedom}{DOF} to a finite number of DOFs. We combine this set of equations of element equations into a global system of equations to solve for the final problem.

	\begin{figure}[b]
	\centering
	\includegraphics[width=0.4\linewidth]{./figures/eulerian/finiteElementDefinitions.pdf}
	\caption{A two-dimensional Finite Element geometry. The cell represents the area of the element, and vertices are the edge of the cell.}
	\label{fig:finiteElementDefinitions}
	\end{figure}

The discretization of a 2D domain can be observed in figure \ref{fig:finiteElementDefinitions}. The figures shows two connect finite elements. The cells represent the area of the element, and vertices of the cell are the node of the finite element. Therefore, we have divide the domain $\Omega$ into finite sets of cells $\mathcal{T}_h = \{T\}$ and together these cells make the mesh of the Eulerian domain. In 2D, the cells are made of simple geometrical shapes such as triangles, quadrilaterals, and tetrahedrals. There are two approaches to discretize the domain: structured and unstructured mesh. The structured mesh have cells that are of similar shape, such as rectangles and is the simplest approach in discretizing the mesh. The advantage of such discretization is that it has simple data structure and and can perform efficient computation. The downside is that the mesh quality deterioates ws the complexity of the domain increases. The common strategy of discretizing the domain for finite element method is to use an unstructured mesh, figure \ref{fig:cylinderFiniteElementDiscretization}. Even though this mesh data structure is complex, the advantage is that the mesh quality does not deteriorate with the domain complexity.

There are several algorithms for mesh generation. The standard approach is to employ the Delaunay triangulation method derived from the Voronoi diagram concept \cite{Carey1997}. This divides the domain into arbitrary number of triangles, figure \ref{fig:cylinderFiniteElementDiscretization}. This type of mesh generation allows us to connect shapes of different types in a simple manner. Furthermore, the triangulation method be controlled by predefining the boundary edges.

\begin{figure}[t]
        \centering
        \begin{subfigure}[b]{0.5\textwidth}
                \includegraphics[width=\textwidth]{figures/eulerian/cylinderPreDelauney-crop.pdf}
                \caption{Fluid domain $\Omega_E$ around the cylinder}
                \label{fig:cylinderPreDelauney}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.5\textwidth}
                \includegraphics[width=\textwidth]{figures/eulerian/cylinderDelauney-crop.pdf}
                \caption{Delaunay triangulation of the fluid}
                \label{fig:cylinderDelauney}
        \end{subfigure}
        \caption{Delaunay triangulation of the fluid around a cylinder resulting in unstructured mesh with controllable cell sizes.}
        \label{fig:cylinderFiniteElementDiscretization}
\end{figure}	

\subsection*{Finite element function and function space}

When the domain $\Omega$ is divided into cells $T$, we can define the function and the function space of the Finite element problem. For each cell, a local function space $\mathcal{V}$ can be defined to collectively construct the global function space $V$.

Any given function $u \in V$ is a expressed in a linear combination of basis functions $\{\phi_1,\phi_2,...,\phi_N\}$  of the function space $V$:

	\begin{equation}
	u(x) = \sum_{j=1}^N U_j\phi_j(x).
	\end{equation}

There are several numbers of Finite Element families, such as Brezzi-Douglas-Marini, Crouzeiz-Raviart, Discontinuous Lagrange, Hermite, and Lagrange elements \cite{Logg2012a}. Each has its own advantage such as the Discontinous Lagrange, also referred to as \indexAcron{Discontinous Galerkin}{DG} element consists of functions that are totally discontinuous. Originally introduced for hyperbolic problem by Reed and Hill \cite{Reed1973}, the method ables to conserve mass at each element, and are high-order accuracy and robust in solving advection problem. However, for the current problem, we have relied on the standard Lagrange elements, also known as \indexAcron{Continuous Galerkin}{CG}, which are based on the Lagrange polynomials \cite{Chen2011}.

\subsection*{Variational problem}
\label{subsec:variationalProblem}

To solve a basic problem such as a Poisson equation numerically, we need to convert it into a variational problem. The methodology is followed from the \texttt{FEniCS} tutorial provide by Langtangen \cite{Langtangen2012}. A 1D Poisson problem is given as,

	\begin{subequations}
	\begin{align*}
	- \nabla^2 u(x) &= f(x), \qquad x\ \mathrm{in}\ \Omega,\\
	u(x) &= u_0(x), \qquad x\ \mathrm{on}\ \partial\Omega.
	\end{align*}
	\label{eq:poissonEq}
	\end{subequations}
	
We can transform equation \ref{eq:poissonEq} into the variational form by multiplying with a test function $v$, and integrating it over the domain $\Omega$,


	\begin{equation}
	- \int_{\Omega} \left(\nabla^2 u\right)v\ \mathrm{d}x= \int_{\Omega} fv\ \mathrm{d}x.
	\label{eq:poissonEqVariationFormA}
	\end{equation}

The function $u$ in variational form, equation \ref{eq:poissonEqVariationFormA}, is known as the trial function and it is the solution that we are trying to approximate. The test function $v$ lies in the test function space $\hat{V}$ and our trial function $u$ lies on the function space $V$. When performing integration by parts, the test function $v$ is required to be zero at regions where $u$ is known. So, the additional terms cancel and we get,

	\begin{equation}
	- \int_{\Omega} \nabla u \nabla v\ \mathrm{d}x= \int_{\Omega} fv\ \mathrm{d}x \qquad \forall v \in \hat{V}
	\label{eq:poissonEqVariationFormB}
	\end{equation}

This form is referred to as the ``weak-form" of the original Poisson equation and is valid for all $v$ in the trial space $\hat{V}$. In order to solve this continuous problem numerically, we must discretize it first into discrete variational problem,

	\begin{equation}
	- \int_{\Omega} \nabla u_h \nabla v\ \mathrm{d}x= \int_{\Omega} fv\ \mathrm{d}x \qquad \forall v \in \hat{V}_h \subset \hat{V},
	\label{eq:poissonEqDiscreteVariational}
	\end{equation}

where $u_h$ is the discrete function in the discrete space $V_h$ which is a subset of $V$ and the discrete function space $\hat{V}_h$ is a subset of $\hat{V}$. A common choice for the function space is linear triangular element with three nodes, figure \ref{fig:finiteElementDefinitions}, where $\hat{V}_h$ and $V_h$ are described by the piecewise linear functions of the triangles and the functions of this function of the test space is zero at the boundary and the function of the trial space is equal to the boundary condition $u_0$.

The equation \ref{eq:poissonEqDiscreteVariational} can be summarized as follows,

	\begin{equation}
	a\left(u,v\right) = L(v),
	\label{eq:weakForm}
	\end{equation}

where $a\left(u,v\right) = - \int_{\Omega} \nabla u \nabla v\ \mathrm{d}x$, and $L(v)=\int_{\Omega}fv\ \mathrm{d}x$ and is referred to as bilinear and linear form, respectively. To solve for the discrete solution we substitute,
	
	\begin{equation}
	u = \sum_{j=1}^{N} U_j \phi_j,
	\label{eq:trialDiscrete}
	\end{equation}

a linear combination of the basis function $\phi_j$, spanning the function space $V$, into $a\left(u,v\right)$. The test function is linear combination of the basis function $\hat{\phi}_i$, spanning the test space $\hat{V}$, is defined as

	\begin{equation}
	v=\sum_{i=1}^{N} \hat{\phi}_i.
	\label{eq:testDiscrete}
	\end{equation}
	
The test function $v$ is taken to be zero at the boundary and one everywhere else. Substituting equation \ref{eq:trialDiscrete} and \ref{eq:testDiscrete} into equation \ref{eq:weakForm} gives,
	
	\begin{equation}
	\sum_{j=1}^N a(\phi,\hat{\phi}_i)\ U_j = L(\hat{\phi}_i).
	\end{equation}

Thus, we have to solve a linear system of equations given as,

	\begin{equation}
	\mathbf{A}U = b,
	\label{eq:linearSysOfEq}
	\end{equation}	
	
where $\mathbf{A}_{ij} = a(\phi_j,\hat{\phi}_i)$ is the coefficient matrix, and $b$ is the \printAcron{Right-Hand Side}{RHS} containing the knowns of the problem.
 	
%------------------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------------------
\section{Solving the Finite Element problem}

To solve this linear system of equations, equation \ref{eq:linearSysOfEq}, we use the \fenics Project that has implemented a comprehensive library of finite elements, and high performance linear algebra. The \dolfin library from the \fenics Project was used to define the Eulerian domain of the hybrid coupling scheme.

In order to generate the mesh of the fluid domain, we used \gmsh, a three-dimensional finite element mesh generator which proves a fast, light and user-friendly meshing tools.

\subsection{Introduction to FEniCS Project}

	\begin{figure}[t]
	\centering
	\includegraphics[width=0.5\linewidth]{./figures/eulerian/dolfinExampleFigure-rotated270.pdf}
	\caption{\texttt{DOLFIN} \texttt{VTK} plot of the Poisson solution, given by the problem, source code listing \ref{lst:pycode-poisson}.}
	\label{fig:dolfinExampleFigure}
	\end{figure}

The \fenics Project is a collaborative work of various universities, that developed tools to automated Finite Element Methods for solving the solutions of differential equation \cite{FenicsAbout}. It was a project originated in 2003 with the research collaboration of University of Chicago and Chalmers University of Technology with Logg,  Mardal, and Wells \cite{Logg2012a}. Since then, it has been expanded to various institutes such as Royal Institute of Technology, Simula Research Laboratory, Univeristy of Cambridge, and Delft Universty of Technology.

	\begin{listing}[p]
	\inputminted[fontseries=courier,obeytabs,fontsize=\footnotesize,mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,xleftmargin=20mm,xrightmargin=20mm]{python}{figures/eulerian/dolfinExample.py}
	\caption{A complete program for solving the Poisson problem and plotting the solution. The Poisson problem is given as $-\nabla^2{u} = f$, where $u_0 = \sin{x}\cdot\cos{y}$ on the boundary and $f=2$. The code is written in python using \texttt{DOLFIN} 1.2 library}
	\label{lst:pycode-poisson}
	\end{listing}

The consists of various libraries such as \textsc{UFC}, \textsc{UFL}, \textsc{FIAT}, \textsc{INSTANT} and mainly \textsc{Dolfin}. \dolfin is the core library aimed at automating the solution of partial differential equations using finite element method \cite{Logg2011}. It uses automated code generation maintaining high level of mathematical expressions and internally providing efficient, multi-threaded performance using the \indexAcron{Message Passing Interface}{MPI}. It used built-in linear algebra backend such as \textsc{PETSc}, \textsc{Trilinos/Epectra}, \textsc{uBLAS}, and \textsc{MTL4}.

The Poisson problem to with the source code was evaluated is given by,

	\begin{equation}
	-\nabla^2 u = f,
	\end{equation}

where $f=2$ and $u(x) = u_0(x) = \sin x \cdot \cos y$ on boundary $\partial \Omega$ can be automated using the \texttt{DOFLIN} library. The solution algorithm follows from section \ref{subsec:variationalProblem}. The ection \ref{subsec:variationalProblem} can be seen in listing \ref{lst:pycode-poisson}.

\subsection{Mesh generation using GMSH}

The proper generation of the fluid mesh is an important aspect of the Finite Element method. It is a non-trivial process, as a non-ideal mesh can be computationally expensive, given un-precise data, and even cause convergence issues. There have been literatures dedicated just to improve the mesh generation, that focuses of improving the quality of the mesh thereby increasing the quality of the data and increasing the robustness of the simulation \cite{Hansen2005}. 

We used \gmsh an open-source finite element mesh generator, which has implemented a user-friendly interface and fast algorithms, developed by Geuzaine and Remacle \cite{Geuzaine2009a}. Its kernel uses \textsc{BLAS} and \texttt{LAPACK} linear algebra packages, and is written in \texttt{C++}. It allows for scriptability making it ideal to chain it with our current \texttt{Python} code project for automation.

\section{Solving Incompressible Navier-Stokes Equations}
The finite element method will be used to describe the Eulerian domain of the hybrid scheme. In the Lagrangian domain, we have used the vorticity-velocity formulation of the Navier-Stokes to describe the evolution of the vorticity in the wake. In the Eulerian domain, where have the no-slip boundary, we have decided to use the primitive variables for formulation the fluid dynamics problem. 

\subsection{Velocity-pressure formulation}
The velocity-pressure formulation is the standard formulation of the Navier-Stokes equations of the fluid dynamics problem. The 2-D incompressible Navier-Stokes equations of unit fluid density is given as,

	\begin{subequations}
	\begin{align}
	\frac{\partial \mathbf{u}}{\partial t} + \mathbf{u}\cdot\nabla\mathbf{u} - \nabla \cdot \sigma &= f,\\
	\nabla \cdot \mathbf{u} = 0,
	\end{align}	
	\label{eq:2Dns}
	\end{subequations}

where $\sigma$ is the Cauchy stress tensor given as,

	\begin{equation}
	\sigma(\mathbf{u},p) = 2\nu\epsilon(\mathbf{u}) - p\mathbf{I}.
	\end{equation}

The problem contains our two unknowns which are the velocity field $\mathbf{u}$ and our pressure field $p$. The problem is function of the viscosity $\nu$, external force $f$ and the symmetric gradient,

	\begin{equation}
	\epsilon(u) = \frac{1}{2} \left(\nabla \mathbf{u} + \nabla \mathbf{u}^{\mathrm{T}}\right).
	\label{eq:symGrad}
	\end{equation}

The velocity field $\mathbf{u}$ is vector function that lies on the vector-valued function space $V$ and scalar pressure field $p$ lies on the function space $Q$.

\subsection{Incremental pressure correction scheme}

The algorithm to solve the Navier-Stokes problem was first demonstrated by Chorin in 1968 \cite{Chorin1968}, nowadays referred to as Chorin's projection method or non-incremental pressure correction scheme. The process relied on first computing a tentative velocity by initially neglecting the pressure in the momentum equation of the Navier-Stokes problem, equation \ref{eq:2Dns}. The velocity field is corrected by determining the pressure field satisfying a divergence free vector field. This method however does not satisfy the discrete incompressibility constraint exactly and Goda 1979 \cite{Goda1979a}, has introduced a improvement to scheme known as the \indexAcron{Incremental Pressure Correction Scheme}{IPCS}.

The method computed the viscous term at the incremented time $(t_{n-1} + t_n)/2$ and used the stress formulation determining the corrected pressure \cite{Logg2012a}. The algorithms to the IPCS scheme can be summarized as follows:

	\begin{enumerate}
	\item \textbf{Compute the tentative velocity:} The tentative velocity given as $\mathbf{u}^{\star}$ is determined by solving
	
		\begin{equation}
		\begin{split}
		\langle D_t^n \mathbf{u}^{\star}, v \rangle &+ \langle \mathbf{u}^{n-1}\cdot\nabla\mathbf{u}^{n-1},v\rangle + \langle \sigma(\mathbf{u}^{n-\frac{1}{2}},p^{n-1}), \epsilon(v) \rangle \quad \\ &\quad+ \langle p^{n-1}\hat{\mathbf{n}},v\rangle_{\partial \Omega} - \langle v\hat{\mathbf{n}} \cdot (\nabla u^{n-\frac{1}{2}} )^{\mathrm{T}},v \rangle_{\partial \Omega} = \langle f^n,v \rangle,
		\end{split}
		\end{equation}
		
	where $\langle u,v \rangle = \int_{\Omega} u(x)v(x)\ \mathrm{d}x$ is the inner product of the two functions. The term $u^{n-\frac{1}{2}}$ is defined as $u^{n-\frac{1}{2}} = (u^{\star}+u^{n-1})/2$. The equation is given for all test function $v \in V$, with the valid dirichlet velocity boundary conditions at boundary $\partial \Omega$.
	
	\item \textbf{Determine the corrected pressure:} The corrected pressure $p^n$ is determined by solving
	
		\begin{equation}
		\langle \nabla p^n, \nabla q \rangle = \langle \nabla p^{n-1}, \nabla q\rangle - \langle \nabla \cdot u^{\star}, q \rangle / \Delta t_n
		\end{equation}
	
	with the valid pressure boundary condition, and the test function $q \in Q$. Using the corrected pressure, we can determine the final corrected velocity field. 
		
	\item \textbf{Determine the corrected velocity:} The corrected velocity field $u^n$ is determined by solving
	
		\begin{equation}
		\langle u^n, v\rangle = \langle u^{\star},v \rangle - \Delta t_n \langle \nabla(p^n - p^{n-1}),v \rangle,
		\end{equation}
		
	for the velocity boundary condition.
		
	\end{enumerate}
	
	\begin{figure}[t]
	\centering
	\includegraphics[width=0.7\linewidth]{./figures/eulerian/multiStep-crop.pdf}
	\caption{Eulerian multi-stepping to match the lagrangian $\Delta t_L$. The figures shows $\Delta t_L = 4 \Delta t_E$ and required $k_E = 4$ iterations to time march from $t_n$ to $t_{n+1}$.}
	\label{fig:multiStep}
	\end{figure}
	
	
This algorithm was implemented using \texttt{DOLFIN}'s Krylov \texttt{GMRES} solver with absolute and relative error tolerance of \num{e-25} and \num{e-12} respectively. The program structure was based on the collection of benchmark and solvers provided by the \texttt{FEniCS} examples scripts \cite{nsbench}.

The algorithm described above an explicit time marching scheme, also referred to as \indexAcron{Forward Euler}{FE}, which is the simplest time marching scheme. Therefore, for the time marching scheme to be stable, we require the CFL number satisfy the following condition:

	\begin{equation}
	\mathrm{CFL} = \Delta t_{\mathrm{max}} \frac{\lVert\mathbf{u}\rVert_{\mathrm{max}}(\nu +  \Delta h_{\mathrm{min}}\lVert\mathbf{u}\rVert_{\mathrm{max}})}{\Delta h_{\mathrm{min}}^2} \le 1.
	\end{equation}
	
This gives us the direct constraint on the maximum Eulerian time step size $\Delta t_{E,\mathrm{max}}$ which is function of the $\mathrm{CFL}$ number, maximum fluid velocity in the Eulerian domain $\lVert \mathbf{u} \rVert_{\mathrm{max}}$, the fluid viscosity $nu$ and the minimum mesh cell size $\Delta h_{min}$. When coupling with the Lagrangian method, we will see that $\Delta t_E \le \Delta t_L$ (Lagrangian time step size is ideally larger than Eulerian time step size), meaning that we will have to perform $k_E$ Eulerian sub-steps to reach the Lagrangian step, figure \ref{fig:multiStep}.

\subsection{Determining the vorticity field}

	\begin{listing}[t]
	\inputminted[fontseries=courier,obeytabs,fontsize=\footnotesize,mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,xleftmargin=20mm,xrightmargin=20mm]{python}{figures/eulerian/vorticity.py}
	\caption{The \textsc{python} implementation of the vorticity calculation}
	\label{lst:pycode-vorticity}
	\end{listing}

The coupling between the Eulerian to Lagrangian method is through the transfer of the vorticity field $\omega$ from the Eulerian domain to the Lagrangian vortex blobs. The vorticity field $\omega$, is defined as,

	\begin{equation}
	\omega = \nabla \times u,
	\label{eq:vorticityEq}
	\end{equation}

and is defined as the curl of the velocity field $\mathbf{u}$. Using the IPCS scheme, the finite element method that we have employed solves for the velocity field and the pressure field. Therefore, to derive the vorticity field, we simply have to take the curl of our solution. However, as this evaluation have to be done at every step (i.e $t_n, t_{n+1}, ...$ of figure \ref{fig:multiStep}), we have to solve this problem in a efficient manner. An efficient process, that \textsc{FEniCS} has implemented, is by pre-assemble the known of the problem, so that the only terms we have to redefine the unknowns of the problem. To do this, we must first define equation \ref{eq:vorticityEq} in the variational (integral) form, 

	\begin{equation}
	\int_{\Omega} \omega \cdot v\ \mathrm{d}x = \int_{\Omega} (\nabla \times u) \cdot v\ \mathrm{d}x,
	\end{equation}

where $\omega = \sum_{j=1}^N \hat{\omega}_j\psi_j$, is a linear combination of basis function $\psi_j$, spanning the function space $W$. The variational form is summarized as

	\begin{equation}
	a(\omega,v) = L(v)
	\end{equation}

where $a(\omega,v)$ contains the knowns of the problem and can be pre-calculated to optimize the problem. $L(v)$ is the unknown of the problem which has to be recalculated every time we need to solve the problem. The \textsc{python} implementation of the algorithm is show in listing \ref{lst:pycode-vorticity} and we see the $\mathrm{LHS}$ of the problem is pre-evaluated using the \texttt{assemble} function of the \textsc{dolfin} library.

\subsection{Determining the body forces}

	\begin{listing}[t]
	\inputminted[fontseries=courier,obeytabs,fontsize=\footnotesize,mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,xleftmargin=20mm,xrightmargin=20mm]{python}{figures/eulerian/forces.py}
	\caption{The \textsc{python} implementation of the force calculation}
	\label{lst:pycode-forceCalculation}
	\end{listing}

Once we solved for flow fields, it is a common strategy to verify the results using some sort of quantities. In aerodynamics, (especially in aerospace field), we like the evaluated the lift and drag coefficient of a given geometry and compare the results to available literature. In order to determine these coefficient, we must first determines the 
friction force and the pressure force acting on the no-slip boundary, or simply put, it is the total stress tensor $\sigma$ acting on the surface of the body.

The stress tensor $\sigma$ is given by

	\begin{equation}
	\sigma(\mathbf{u},p) = 2\nu\epsilon(\mathbf{u}) - p\mathbf{I},
	\end{equation}

where $\epsilon$ is the symmetric gradient, equation \ref{eq:symGrad}, and is a function of the velocity $\mathbf{u}$ and the pressure $p$ acting on the surface.The lift coefficient and the drag coefficient is computed as,

	\begin{subequations}
	\begin{align}
	L &= \int_{\partial \Omega} \left[\sigma(\mathbf{u},p) \cdot \hat{\mathbf{n}}\right]\cdot \hat{\mathbf{e}}_y\ \mathrm{d}s,\\
	D &= \int_{\partial \Omega} \left[\sigma(\mathbf{u},p) \cdot \hat{\mathbf{n}}\right]\cdot \hat{\mathbf{e}}_x\ \mathrm{d}s,
	\end{align}
	\end{subequations}

where $\hat{\mathbf{e}}_x$ and $\hat{\mathbf{e}}_y$ are the 2D unit Cartesian vectors $[1,0]$ and $[0,1]$ respectively. The lift coefficient and the drag coefficient, $C_l$ and $C_d$ respectively, is the lift and drag normalized with the dynamics pressure and reference length $c$ (in 2D), where the lift perpendicular to the free-steam and the drag is tangential to it,

		\begin{subequations}
		\begin{align}
		C_l &= \frac{L}{\frac{1}{2}\lVert\mathbf{u}\rVert_{\infty}^2 c},\\
		C_d &= \frac{D}{\frac{1}{2}\lVert\mathbf{u}\rVert_{\infty}^2 c}.
		\end{align}
		\end{subequations}

\section{Validation of eulerian method}

\subsection{Lamb-Oseen Vortex}

	\begin{figure}[b]
	\centering
	\includegraphics[width=0.7\linewidth]{./figures/eulerian/lambOseen_eulerian_wRelEvolution_compressed.pdf}
	\caption{Eulerian Lamb-Oseen relative vorticity evolution}
	\label{fig:lambOseen_eulerian_wRelEvolution}
	\end{figure}


	\begin{figure}[b]
        \centering
        \begin{subfigure}[b]{0.5\textwidth}
                \includegraphics[width=\textwidth]{figures/eulerian/lambOseen_eulerianConvergence_dx_compressed.pdf}
                \caption{Lamb-Oseen dx convergence}
                \label{fig:lambOseen_eulerianConvergence_dx}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.5\textwidth}
                \includegraphics[width=\textwidth]{figures/eulerian/lambOseen_eulerianConvergence_dt_compressed.pdf}
                \caption{Lamb-Oseen dt convergence}
                \label{fig:lambOseen_eulerianConvergence_dt}
        \end{subfigure}
        \caption{Lamb-Oseen convergence}
        \label{fig:lambOseen_eulerianConvergence}
	\end{figure}	

\subsection{Clercx-Bruneau dipole collison at $Re=625$}

\subsection{Impulsively started cylinder at $Re=550$}

\section{Summary}

